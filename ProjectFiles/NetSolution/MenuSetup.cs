#region Using directives
using System;
using System.Collections.Generic;
using System.Linq;
using UAManagedCore;
using OpcUa = UAManagedCore.OpcUa;
using FTOptix.UI;
using FTOptix.HMIProject;
using FTOptix.NativeUI;
using FTOptix.RAEtherNetIP;
using FTOptix.Retentivity;
using FTOptix.CoreBase;
using FTOptix.CommunicationDriver;
using FTOptix.NetLogic;
using FTOptix.Core;
using FTOptix.Store;
using FTOptix.ODBCStore;
using FTOptix.Report;
using FTOptix.System;
using FTOptix.EventLogger;
using FTOptix.DataLogger;
using FTOptix.Alarm;
using FTOptix.SerialPort;
using FTOptix.SQLiteStore;
using FTOptix.AuditSigning;
#endregion

/// <summary>
/// AI GENERATE CODE
/// 
/// MenuSetup NetLogic - Automatically generates cascading/nested dropdown menus
/// based on a folder structure in the UI hierarchy.
/// 
/// STRUCTURE OVERVIEW:
/// - Source folder: UI/_AutomaticMenuCreation_ (configurable via SOURCE_FOLDER_PATH)
/// - Output location: UI/Screens/DropDowns (configurable via DROPDOWN_OUTPUT_PATH)
/// - Button types sourced from: UI/DropDowns/DropDownButtons
/// 
/// MENU HIERARCHY:
/// - L1 (Area level): e.g., Refining_Bleaching, Deodorizing
/// - L2 (Sub-area level): e.g., Degumming_L2, Separation_L2
/// - L3 (Detail level): e.g., CrudeHeatingCooling_L3
/// - L4+ (Additional levels): Extensible for future needs
/// 
/// BUTTON TYPES:
/// - Dropdown_NoBoarder: Direct screen navigation (MouseClick -> ChangePanel)
/// - Dropdown_Arrow: Opens submenu flyout to the right
/// 
/// FLYOUT TEMPLATE:
/// - Based on "Flyout" type in DropDowns folder
/// - Auto-sized based on number of items
/// </summary>
public class MenuSetup : BaseNetLogic
{
    #region Configuration Constants
    // ============================================================================
    // CONFIGURATION SECTION - Modify these constants to customize behavior
    // ============================================================================
    // NOTE: Paths use Project.Current.Get() which expects path WITHOUT project name.
    //       Get path by right-clicking node in IDE -> "Copy path to node" -> remove project name prefix.

    /// <summary>
    /// Path to the source folder containing the menu structure.
    /// This folder's subfolders and screens define the menu hierarchy.
    /// </summary>
    private const string SOURCE_FOLDER_PATH = "UI/Screens/<AutomaticMenuCreation>";

    /// <summary>
    /// Path where generated dropdown menus will be created.
    /// Menus are created as children of this folder.
    /// </summary>
    private const string DROPDOWN_OUTPUT_PATH = "UI/Screens/DropDowns/AutoGeneratedMenus";

    /// <summary>
    /// Path to the folder containing button type definitions.
    /// Contains Dropdown_NoBoarder and Dropdown_Arrow types.
    /// </summary>
    private const string BUTTON_TYPES_PATH = "UI/Screens/DropDowns/DropDownButtons";

    /// <summary>
    /// Full path to the Flyout type used as template for menu panels.
    /// This type is cloned/instantiated for each submenu.
    /// </summary>
    private const string FLYOUT_TYPE_PATH = "UI/Screens/DropDowns/Flyout";

    /// <summary>
    /// Button type name for direct screen navigation (no submenu).
    /// </summary>
    private const string BUTTON_DIRECT_LINK = "Dropdown_NoBoarder";

    /// <summary>
    /// Button type name for opening submenus (has arrow indicator).
    /// </summary>
    private const string BUTTON_SUBMENU_LINK = "Dropdown_Arrow";

    /// <summary>
    /// Height of each button item in the menu (in pixels).
    /// Used for calculating total menu height.
    /// </summary>
    private const float BUTTON_HEIGHT = 28.0f;

    /// <summary>
    /// Width of the menu panel (in pixels).
    /// </summary>
    private const float MENU_WIDTH = 154.0f;

    /// <summary>
    /// Vertical padding/margin for the menu panel (in pixels).
    /// Added to the total calculated height.
    /// </summary>
    private const float MENU_VERTICAL_PADDING = 12.0f;

    /// <summary>
    /// Prefix for generated menu names to avoid naming conflicts.
    /// </summary>
    private const string MENU_NAME_PREFIX = "Menu_";

    #endregion

    #region Private Fields
    // ============================================================================
    // PRIVATE FIELDS - Runtime references cached during execution
    // ============================================================================

    /// <summary>
    /// Reference to the Flyout type used as template for creating menus.
    /// </summary>
    private IUANode _flyoutType;

    /// <summary>
    /// Reference to the direct link button type (Dropdown_NoBoarder).
    /// </summary>
    private IUANode _directLinkButtonType;

    /// <summary>
    /// Reference to the submenu button type (Dropdown_Arrow).
    /// </summary>
    private IUANode _submenuButtonType;

    /// <summary>
    /// Reference to the output folder where menus are created.
    /// </summary>
    private IUANode _outputFolder;

    /// <summary>
    /// Counter for generating unique button names within menus.
    /// </summary>
    private int _buttonCounter;

    /// <summary>
    /// List to track all created menu objects for cleanup/management.
    /// </summary>
    private List<IUANode> _createdMenus;

    #endregion

    #region Exported Methods
    // ============================================================================
    // EXPORTED METHODS - Callable from FTOptix UI or other NetLogics
    // ============================================================================

    /// <summary>
    /// Main entry point: Generates the complete cascading menu structure.
    /// 
    /// This method:
    /// 1. Initializes required type references
    /// 2. Cleans up any previously generated menus
    /// 3. Recursively processes the source folder structure
    /// 4. Creates Flyout panels with appropriate buttons for each level
    /// 
    /// Call this method to regenerate menus after modifying the folder structure.
    /// </summary>
    [ExportMethod]
    public void Method1()
    {
        // Diagnostic logs at different levels to ensure visibility
        Log.Warning("MenuSetup", "########## Method1 CALLED ##########");
        Log.Error("MenuSetup", "########## Method1 STARTING (Error level for visibility) ##########");
        Log.Info("MenuSetup", "=== Starting Automatic Menu Generation ===");

        try
        {
            // Step 1: Initialize all required type references and validate paths
            if (!InitializeTypeReferences())
            {
                Log.Error("MenuSetup", "Failed to initialize type references. Menu generation aborted.");
                return;
            }

            // Step 2: Get the source folder containing the menu structure
            var sourceFolder = Project.Current.Get(SOURCE_FOLDER_PATH);
            if (sourceFolder == null)
            {
                Log.Error("MenuSetup", $"Source folder not found at: {SOURCE_FOLDER_PATH}");
                return;
            }
            Log.Info("MenuSetup", $"Found source folder: {sourceFolder.BrowseName}");

            // Step 3: Clean up previously generated menus (optional - uncomment if needed)
            // CleanupGeneratedMenus();

            // Step 4: Initialize tracking list for created menus
            _createdMenus = new List<IUANode>();
            _buttonCounter = 0;

            // Step 5: Process the root level - create main menu for each area
            ProcessRootLevel(sourceFolder);

            // Step 6: Link created menus to their trigger buttons in the UI
            LinkMenusToTriggerButtons(sourceFolder);

            Log.Info("MenuSetup", $"=== Menu Generation Complete. Created {_createdMenus.Count} menu(s) ===");
        }
        catch (Exception ex)
        {
            Log.Error("MenuSetup", $"Error during menu generation: {ex.Message}");
            Log.Error("MenuSetup", $"Stack trace: {ex.StackTrace}");
        }
    }

    /// <summary>
    /// Cleans up previously generated menus.
    /// Removes all menus that have the MENU_NAME_PREFIX.
    /// </summary>
    [ExportMethod]
    public void Method2()
    {
        // Cleanup previously generated menus
        CleanupGeneratedMenus();
    }

    #endregion

    #region Initialization Methods
    // ============================================================================
    // INITIALIZATION METHODS - Setup and validation of required references
    // ============================================================================

    /// <summary>
    /// Initializes all type references required for menu generation.
    /// Validates that all required types and folders exist.
    /// 
    /// PATH RESOLUTION (from FTOptix documentation):
    /// - Project.Current.Get("path") expects path WITHOUT the project name
    /// - Get path by right-clicking node in IDE -> "Copy path to node" -> remove project name
    /// </summary>
    /// <returns>True if all references initialized successfully, false otherwise.</returns>
    private bool InitializeTypeReferences()
    {
        Log.Info("MenuSetup", "Initializing type references...");

        // Get the Flyout type (template for menus)
        _flyoutType = Project.Current.Get(FLYOUT_TYPE_PATH);
        if (_flyoutType == null)
        {
            Log.Error("MenuSetup", $"Flyout type not found at: {FLYOUT_TYPE_PATH}");
            return false;
        }
        Log.Info("MenuSetup", $"Found Flyout type: {_flyoutType.BrowseName}");

        // Get the button types
        _directLinkButtonType = Project.Current.Get($"{BUTTON_TYPES_PATH}/{BUTTON_DIRECT_LINK}");
        if (_directLinkButtonType == null)
        {
            Log.Error("MenuSetup", $"Direct link button type not found at: {BUTTON_TYPES_PATH}/{BUTTON_DIRECT_LINK}");
            return false;
        }

        _submenuButtonType = Project.Current.Get($"{BUTTON_TYPES_PATH}/{BUTTON_SUBMENU_LINK}");
        if (_submenuButtonType == null)
        {
            Log.Error("MenuSetup", $"Submenu button type not found at: {BUTTON_TYPES_PATH}/{BUTTON_SUBMENU_LINK}");
            return false;
        }
        Log.Info("MenuSetup", $"Found button types: {_directLinkButtonType.BrowseName}, {_submenuButtonType.BrowseName}");

        // Get the output folder
        _outputFolder = Project.Current.Get(DROPDOWN_OUTPUT_PATH);
        if (_outputFolder == null)
        {
            Log.Error("MenuSetup", $"Output folder not found at: {DROPDOWN_OUTPUT_PATH}");
            return false;
        }
        Log.Info("MenuSetup", $"Output folder: {_outputFolder.BrowseName}");

        return true;
    }

    #endregion

    #region Menu Generation Methods
    // ============================================================================
    // MENU GENERATION METHODS
    // ============================================================================

    /// <summary>
    /// Processes the root level of the source folder.
    /// Creates a main menu for each top-level area (e.g., Refining_Bleaching, Deodorizing).
    /// </summary>
    /// <param name="sourceFolder">The root folder containing area subfolders.</param>
    private void ProcessRootLevel(IUANode sourceFolder)
    {
        Log.Info("MenuSetup", $"Processing root level folder: {sourceFolder.BrowseName}");

        // Get all children that are folders or screens
        var children = sourceFolder.Children.ToList();
        Log.Info("MenuSetup", $"Root folder has {children.Count} children");

        foreach (var child in children)
        {
            Log.Info("MenuSetup", $"  Examining child: {child.BrowseName} (NodeClass={child.NodeClass})");
            
            // Skip non-relevant children (variables, etc.)
            if (IsFolder(child))
            {
                // This is an area folder - create a menu for it
                Log.Info("MenuSetup", $"  -> FOLDER: {child.BrowseName}");
                ProcessAreaFolder(child, null);
            }
            else if (IsScreen(child))
            {
                // Direct screen at root level (unusual but supported)
                Log.Info("MenuSetup", $"  -> SCREEN: {child.BrowseName}");
            }
            else
            {
                Log.Info("MenuSetup", $"  -> SKIPPED (not folder or screen): {child.BrowseName}");
            }
        }
    }

    /// <summary>
    /// Processes an area folder and creates its corresponding menu.
    /// An area folder may contain:
    /// - Direct screens (L1 screens)
    /// - L2 subfolders containing more screens and L3 folders
    /// </summary>
    /// <param name="areaFolder">The area folder to process.</param>
    /// <param name="parentMenuName">Name of the parent menu (null for root areas).</param>
    /// <returns>The created menu panel, or null if no items to display.</returns>
    private IUANode ProcessAreaFolder(IUANode areaFolder, string parentMenuName)
    {
        Log.Info("MenuSetup", $"Processing area folder: {areaFolder.BrowseName}");

        // Collect all menu items for this folder
        var menuItems = new List<MenuItemInfo>();

        // Get all children
        var children = areaFolder.Children.ToList();

        foreach (var child in children)
        {
            if (IsScreen(child))
            {
                // Direct screen - add as direct link button
                menuItems.Add(new MenuItemInfo
                {
                    Name = FormatDisplayName(child.BrowseName),
                    NodePath = GetNodePath(child),
                    IsSubmenu = false,
                    SourceNode = child
                });
                Log.Info("MenuSetup", $"  - Added screen: {child.BrowseName}");
            }
            else if (IsFolder(child))
            {
                // Subfolder - recursively process and create submenu
                var submenu = ProcessSubfolder(child, areaFolder.BrowseName);
                if (submenu != null)
                {
                    menuItems.Add(new MenuItemInfo
                    {
                        Name = FormatDisplayName(child.BrowseName),
                        NodePath = GetNodePath(submenu),
                        IsSubmenu = true,
                        SourceNode = child,
                        SubmenuPanel = submenu
                    });
                    Log.Info("MenuSetup", $"  - Added submenu: {child.BrowseName}");
                }
            }
        }

        // Create the menu panel if there are items
        if (menuItems.Count > 0)
        {
            string menuName = $"{MENU_NAME_PREFIX}{areaFolder.BrowseName}";
            return CreateMenuPanel(menuName, menuItems);
        }

        return null;
    }

    /// <summary>
    /// Processes a subfolder (L2, L3, L4, etc.) and creates its menu.
    /// This method is recursive and can handle any depth of folder nesting.
    /// 
    /// FOLDER NAMING CONVENTION:
    /// - Screens with names matching "{FolderName}_L#" are grouped under that folder
    /// - Example: Degumming_L2 screen relates to Degumming_L3 folder
    /// </summary>
    /// <param name="folder">The subfolder to process.</param>
    /// <param name="parentName">Name of the parent folder for context.</param>
    /// <returns>The created submenu panel, or null if no items.</returns>
    private IUANode ProcessSubfolder(IUANode folder, string parentName)
    {
        Log.Info("MenuSetup", $"Processing subfolder: {folder.BrowseName} (parent: {parentName})");

        // Collect all menu items for this subfolder
        var menuItems = new List<MenuItemInfo>();

        // Get all children
        var children = folder.Children.ToList();
        Log.Info("MenuSetup", $"  Subfolder {folder.BrowseName} has {children.Count} children");

        foreach (var child in children)
        {
            Log.Info("MenuSetup", $"    Examining: {child.BrowseName} (NodeClass={child.NodeClass})");
            
            if (IsScreen(child))
            {
                // Add screen as direct link
                menuItems.Add(new MenuItemInfo
                {
                    Name = FormatDisplayName(child.BrowseName),
                    NodePath = GetNodePath(child),
                    IsSubmenu = false,
                    SourceNode = child
                });
                Log.Info("MenuSetup", $"    -> Added as SCREEN: {child.BrowseName}");
            }
            else if (IsFolder(child))
            {
                // Recursive call for nested folders (L3, L4, etc.)
                // This enables unlimited nesting depth for future expansion
                var nestedSubmenu = ProcessSubfolder(child, folder.BrowseName);
                if (nestedSubmenu != null)
                {
                    menuItems.Add(new MenuItemInfo
                    {
                        Name = FormatDisplayName(child.BrowseName),
                        NodePath = GetNodePath(nestedSubmenu),
                        IsSubmenu = true,
                        SourceNode = child,
                        SubmenuPanel = nestedSubmenu
                    });
                    Log.Info("MenuSetup", $"    -> Added as SUBMENU: {child.BrowseName}");
                }
            }
            else
            {
                Log.Info("MenuSetup", $"    -> SKIPPED (not screen or folder): {child.BrowseName}");
            }
        }

        // Create the submenu panel if there are items
        if (menuItems.Count > 0)
        {
            string menuName = $"{MENU_NAME_PREFIX}{parentName}_{folder.BrowseName}";
            Log.Info("MenuSetup", $"  Creating menu '{menuName}' with {menuItems.Count} items");
            return CreateMenuPanel(menuName, menuItems);
        }

        Log.Warning("MenuSetup", $"  NO ITEMS found in subfolder: {folder.BrowseName} (had {children.Count} children but none were screens/folders)");
        return null;
    }

    /// <summary>
    /// Creates a menu panel (Flyout) with the specified items.
    /// The panel is created as an ObjectType (not an instance) so it can be used
    /// by dropdown buttons that require a Type reference.
    /// The panel is sized based on the number of items.
    /// </summary>
    /// <param name="menuName">Unique name for the menu panel type.</param>
    /// <param name="items">List of menu items to add.</param>
    /// <returns>The created menu panel type.</returns>
    private IUANode CreateMenuPanel(string menuName, List<MenuItemInfo> items)
    {
        Log.Info("MenuSetup", $"Creating menu panel TYPE: {menuName} with {items.Count} items");

        // Check if menu already exists and remove it
        var existingMenu = _outputFolder.Get(menuName);
        if (existingMenu != null)
        {
            Log.Info("MenuSetup", $"Removing existing menu: {menuName}");
            existingMenu.Delete();
        }

        // Create the menu panel as an ObjectType (not instance) based on Flyout type
        // This is required because dropdown buttons expect a Type, not an instance
        IUANode menuPanel;
        try
        {
            // Create as ObjectType that inherits from the Flyout type
            // MakeObjectType creates a new Type definition
            menuPanel = InformationModel.MakeObjectType(menuName, _flyoutType.NodeId);
            Log.Info("MenuSetup", $"Created ObjectType: {menuName} based on {_flyoutType.BrowseName}");
        }
        catch (Exception ex)
        {
            // Fallback: Try creating as basic Panel type
            Log.Warning("MenuSetup", $"Could not create ObjectType from Flyout, trying basic approach: {ex.Message}");
            try
            {
                menuPanel = InformationModel.MakeObjectType(menuName, FTOptix.UI.ObjectTypes.Panel);
            }
            catch
            {
                Log.Error("MenuSetup", $"Failed to create ObjectType for {menuName}");
                return null;
            }
        }

        // Calculate and set the panel size based on number of items
        float panelHeight = (items.Count * BUTTON_HEIGHT) + MENU_VERTICAL_PADDING;
        SetPanelSize(menuPanel, MENU_WIDTH, panelHeight);

        // Add buttons for each menu item
        float currentTopMargin = 1.0f; // Starting position for first button
        foreach (var item in items)
        {
            IUANode button;
            if (item.IsSubmenu)
            {
                // Create submenu button with arrow
                button = CreateSubmenuButton(item, currentTopMargin);
            }
            else
            {
                // Create direct link button
                button = CreateDirectLinkButton(item, currentTopMargin);
            }

            if (button != null)
            {
                menuPanel.Add(button);
                currentTopMargin += BUTTON_HEIGHT;
            }
        }

        // Add the menu panel type to the output folder
        _outputFolder.Add(menuPanel);
        _createdMenus.Add(menuPanel);

        Log.Info("MenuSetup", $"Created menu panel TYPE: {menuName} at {DROPDOWN_OUTPUT_PATH}/{menuName}");
        return menuPanel;
    }

    /// <summary>
    /// Creates a direct link button (Dropdown_NoBoarder) that navigates to a screen.
    /// The button's MouseClick event calls {MainPanelLoader}/ChangePanel with the screen as NewPanel.
    /// </summary>
    /// <param name="item">Menu item information containing screen details.</param>
    /// <param name="topMargin">Vertical position of the button within the menu.</param>
    /// <returns>The created button object.</returns>
    private IUANode CreateDirectLinkButton(MenuItemInfo item, float topMargin)
    {
        _buttonCounter++;
        string buttonName = $"Btn_{_buttonCounter}_{SanitizeName(item.Name)}";

        try
        {
            // Create button instance from type and cast to Button for direct property access
            var button = (Button)InformationModel.MakeObject(buttonName, _directLinkButtonType.NodeId);

            // Set button properties directly (FTOptix UI properties)
            button.Text = item.Name;
            button.TopMargin = topMargin;
            button.LeftMargin = 1.0f;
            button.Width = MENU_WIDTH - 4.0f;
            button.Height = BUTTON_HEIGHT;

            // Configure the MouseClick event to call ChangePanel
            ConfigureChangePanelEvent(button, item.NodePath);

            Log.Info("MenuSetup", $"Created direct link button: {buttonName} -> {item.NodePath}");
            return button;
        }
        catch (Exception ex)
        {
            Log.Error("MenuSetup", $"Error creating direct link button '{buttonName}': {ex.Message}");
            return null;
        }
    }

    /// <summary>
    /// Creates a submenu button (Dropdown_Arrow) that opens a nested flyout menu.
    /// The button's Panel property references the submenu Flyout.
    /// </summary>
    /// <param name="item">Menu item information containing submenu details.</param>
    /// <param name="topMargin">Vertical position of the button within the menu.</param>
    /// <returns>The created button object.</returns>
    private IUANode CreateSubmenuButton(MenuItemInfo item, float topMargin)
    {
        _buttonCounter++;
        string buttonName = $"SubBtn_{_buttonCounter}_{SanitizeName(item.Name)}";

        try
        {
            // Create button instance from type and cast to Panel for direct property access
            // Dropdown_Arrow is based on Panel type
            var button = (Panel)InformationModel.MakeObject(buttonName, _submenuButtonType.NodeId);

            // Set panel properties directly (FTOptix UI properties)
            button.TopMargin = topMargin;
            button.LeftMargin = 1.0f;
            button.Width = MENU_WIDTH - 4.0f;
            button.Height = BUTTON_HEIGHT;

            // Search for a Button child within the Panel to set the text
            // Dropdown_Arrow panels typically contain a Button with the display text
            var innerButton = FindButtonInPanel(button);
            if (innerButton != null)
            {
                innerButton.Text = item.Name;
                Log.Info("MenuSetup", $"    Set text on inner button: {innerButton.BrowseName}");

                // Configure the Panel property on the inner button to point to the submenu panel
                // Dropdown buttons use Panel property instead of ChangePanel events
                ConfigurePanelProperty(innerButton, item.NodePath);
            }
            else
            {
                // Fallback: try setting Text via GetVariable on the panel itself
                var textVar = button.GetVariable("Text");
                if (textVar != null)
                {
                    textVar.Value = new LocalizedText("en-US", item.Name);
                    Log.Info("MenuSetup", $"    Set text via GetVariable on panel");
                }
                else
                {
                    Log.Warning("MenuSetup", $"    Could not find Text property on {buttonName}");
                }

                // Fallback: Configure the Panel property on the outer panel
                ConfigurePanelProperty(button, item.NodePath);
            }

            Log.Info("MenuSetup", $"Created submenu button: {buttonName} -> {item.NodePath}");
            return button;
        }
        catch (Exception ex)
        {
            Log.Error("MenuSetup", $"Error creating submenu button '{buttonName}': {ex.Message}");
            return null;
        }
    }

    #endregion

    #region Button Configuration Methods
    // ============================================================================
    // BUTTON CONFIGURATION METHODS - Setup button properties and events
    // ============================================================================

    /// <summary>
    /// Sets the display text on a button.
    /// Text property is directly on the button: {button}/Text
    /// </summary>
    /// <param name="button">The button object.</param>
    /// <param name="text">The text to display.</param>
    private void SetButtonText(IUANode button, string text)
    {
        var textVar = button.GetVariable("Text");
        if (textVar != null)
        {
            textVar.Value = new LocalizedText("en-US", text);
            Log.Info("MenuSetup", $"    Set Text='{text}' on {button.BrowseName}");
        }
        else
        {
            Log.Warning("MenuSetup", $"    Text property not found on {button.BrowseName}");
        }
    }

    /// <summary>
    /// Sets the position and size of a button within the menu.
    /// Properties are directly on the button: {button}/TopMargin, {button}/LeftMargin, etc.
    /// </summary>
    /// <param name="button">The button object.</param>
    /// <param name="topMargin">Vertical position in pixels.</param>
    private void SetButtonPosition(IUANode button, float topMargin)
    {
        // Set TopMargin (vertical position)
        var topMarginVar = button.GetVariable("TopMargin");
        if (topMarginVar != null)
            topMarginVar.Value = topMargin;

        // Set LeftMargin (horizontal position)
        var leftMarginVar = button.GetVariable("LeftMargin");
        if (leftMarginVar != null)
            leftMarginVar.Value = 1.0f;

        // Set Width to match menu width minus margins
        var widthVar = button.GetVariable("Width");
        if (widthVar != null)
            widthVar.Value = MENU_WIDTH - 4.0f;

        // Set Height
        var heightVar = button.GetVariable("Height");
        if (heightVar != null)
            heightVar.Value = BUTTON_HEIGHT;

        Log.Info("MenuSetup", $"    Set position on {button.BrowseName}: Top={topMargin}, Left=1, W={MENU_WIDTH - 4}, H={BUTTON_HEIGHT}");
    }

    /// <summary>
    /// Configures the MouseClick event handler to call ChangePanel method.
    /// This sets up the navigation action for direct link buttons.
    /// 
    /// Event structure:
    /// - EventHandler
    ///   - ListenEventType: MouseClickEvent
    ///   - MethodsToCall
    ///     - MethodContainer1
    ///       - ObjectPointer: {MainPanelLoader}@NodeId (via DynamicLink)
    ///       - Method: "ChangePanel"
    ///       - InputArguments
    ///         - NewPanel: [target screen NodeId]
    ///         - AliasNode: [empty]
    /// </summary>
    /// <param name="button">The button to configure.</param>
    /// <param name="targetScreenPath">Full path to the target screen.</param>
    private void ConfigureChangePanelEvent(IUANode button, string targetScreenPath)
    {
        try
        {
            // Get the target screen node to retrieve its NodeId
            var targetScreen = Project.Current.Get(targetScreenPath);
            if (targetScreen == null)
            {
                Log.Warning("MenuSetup", $"Target screen not found: {targetScreenPath}");
                return;
            }

            // Look for existing MouseClickEventHandler
            var eventHandler = button.Get("MouseClickEventHandler1") as FTOptix.CoreBase.EventHandler;
            
            if (eventHandler == null)
            {
                // Create new event handler if not found
                eventHandler = InformationModel.MakeObject<FTOptix.CoreBase.EventHandler>("MouseClickEventHandler1");
                eventHandler.ListenEventType = FTOptix.UI.ObjectTypes.MouseClickEvent;
                button.Add(eventHandler);
            }

            // Get or create MethodsToCall container
            var methodsToCall = eventHandler.Get("MethodsToCall") as IUAObject;
            if (methodsToCall == null)
            {
                methodsToCall = InformationModel.MakeObject("MethodsToCall");
                eventHandler.Add(methodsToCall);
            }

            // Get or create MethodContainer
            var methodContainer = methodsToCall.Get("MethodContainer1") as IUAObject;
            if (methodContainer == null)
            {
                methodContainer = InformationModel.MakeObject("MethodContainer1");
                methodsToCall.Add(methodContainer);
            }

            // Configure ObjectPointer with DynamicLink to {MainPanelLoader}
            var objectPointer = methodContainer.Get("ObjectPointer") as IUAVariable;
            if (objectPointer == null)
            {
                objectPointer = InformationModel.MakeVariable<NodePointer>("ObjectPointer", OpcUa.DataTypes.NodeId);
                methodContainer.Add(objectPointer);
            }

            // Set up DynamicLink to MainPanelLoader
            var dynamicLink = objectPointer.Get("DynamicLink") as DynamicLink;
            if (dynamicLink == null)
            {
                dynamicLink = InformationModel.MakeVariable<DynamicLink>("DynamicLink", FTOptix.Core.DataTypes.NodePath);
                dynamicLink.Value = "{MainPanelLoader}@NodeId";
                dynamicLink.Mode = DynamicLinkMode.Read;
                objectPointer.Refs.AddReference(FTOptix.CoreBase.ReferenceTypes.HasDynamicLink, dynamicLink);
            }
            else
            {
                dynamicLink.Value = "{MainPanelLoader}@NodeId";
            }

            // Configure Method name
            var methodVar = methodContainer.Get("Method") as IUAVariable;
            if (methodVar == null)
            {
                methodVar = InformationModel.MakeVariable("Method", OpcUa.DataTypes.String);
                methodContainer.Add(methodVar);
            }
            methodVar.Value = "ChangePanel";

            // Configure InputArguments
            var inputArgs = methodContainer.Get("InputArguments") as IUAObject;
            if (inputArgs == null)
            {
                inputArgs = InformationModel.MakeObject("InputArguments");
                methodContainer.Add(inputArgs);
            }

            // Set NewPanel argument to target screen NodeId
            var newPanelArg = inputArgs.Get("NewPanel") as IUAVariable;
            if (newPanelArg == null)
            {
                newPanelArg = InformationModel.MakeVariable("NewPanel", OpcUa.DataTypes.NodeId);
                inputArgs.Add(newPanelArg);
            }
            newPanelArg.Value = targetScreen.NodeId;

            // Ensure AliasNode argument exists (can be empty)
            var aliasNodeArg = inputArgs.Get("AliasNode") as IUAVariable;
            if (aliasNodeArg == null)
            {
                aliasNodeArg = InformationModel.MakeVariable("AliasNode", OpcUa.DataTypes.NodeId);
                inputArgs.Add(aliasNodeArg);
            }

            Log.Info("MenuSetup", $"Configured ChangePanel event for button, target: {targetScreenPath}");
        }
        catch (Exception ex)
        {
            Log.Error("MenuSetup", $"Error configuring ChangePanel event: {ex.Message}");
        }
    }

    /// <summary>
    /// Configures the Panel property of a dropdown button to point to the target panel/screen.
    /// Dropdown buttons use the Panel property to specify which panel to display when clicked.
    /// </summary>
    /// <param name="button">The dropdown button to configure.</param>
    /// <param name="targetPanelPath">Full path to the target panel or screen.</param>
    private void ConfigurePanelProperty(IUANode button, string targetPanelPath)
    {
        try
        {
            // Get the target panel node to retrieve its NodeId
            var targetPanel = Project.Current.Get(targetPanelPath);
            if (targetPanel == null)
            {
                Log.Warning("MenuSetup", $"Target panel not found: {targetPanelPath}");
                return;
            }

            // Look for Panel property (NodePointer type)
            var panelPointer = button.Get("Panel") as IUAVariable;
            if (panelPointer == null)
            {
                // Try to create it if it doesn't exist
                panelPointer = InformationModel.MakeVariable<NodePointer>("Panel", OpcUa.DataTypes.NodeId);
                button.Add(panelPointer);
            }

            // Set the Panel pointer to the target panel's NodeId
            panelPointer.Value = targetPanel.NodeId;

            Log.Info("MenuSetup", $"Configured Panel property: {button.BrowseName} -> {targetPanelPath}");
        }
        catch (Exception ex)
        {
            Log.Error("MenuSetup", $"Error configuring Panel property: {ex.Message}");
        }
    }

    /// <summary>
    /// Sets the size of a menu panel (Width and Height).
    /// </summary>
    /// <param name="panel">The panel to resize.</param>
    /// <param name="width">Width in pixels.</param>
    /// <param name="height">Height in pixels.</param>
    private void SetPanelSize(IUANode panel, float width, float height)
    {
        try
        {
            var widthVar = panel.GetVariable("Width");
            if (widthVar != null)
            {
                widthVar.Value = width;
            }

            var heightVar = panel.GetVariable("Height");
            if (heightVar != null)
            {
                heightVar.Value = height;
            }

            // Also try to update inner background rectangles if they exist
            UpdateBackgroundRectangles(panel, width, height);
        }
        catch (Exception ex)
        {
            Log.Warning("MenuSetup", $"Error setting panel size: {ex.Message}");
        }
    }

    /// <summary>
    /// Updates the size of background rectangles within the menu panel.
    /// The Flyout type may have WhiteBkgrndRectangle elements that need resizing.
    /// </summary>
    /// <param name="panel">The panel containing rectangles.</param>
    /// <param name="width">Width in pixels.</param>
    /// <param name="height">Height in pixels.</param>
    private void UpdateBackgroundRectangles(IUANode panel, float width, float height)
    {
        try
        {
            // Find and resize background rectangles
            var rectNames = new[] { "WhiteBkgrndRectangle", "WhiteBkgrndRectangle1" };
            foreach (var rectName in rectNames)
            {
                var rect = panel.Get(rectName);
                if (rect != null)
                {
                    var rectWidth = rect.GetVariable("Width");
                    var rectHeight = rect.GetVariable("Height");
                    if (rectWidth != null) rectWidth.Value = width - 3.0f;
                    if (rectHeight != null) rectHeight.Value = height - 2.0f;
                }
            }
        }
        catch (Exception ex)
        {
            Log.Warning("MenuSetup", $"Error updating background rectangles: {ex.Message}");
        }
    }

    #endregion

    #region Helper Methods
    // ============================================================================
    // HELPER METHODS - Utility functions for common operations
    // ============================================================================

    /// <summary>
    /// Searches for a Button type object within a Panel's children (recursive).
    /// Used for Dropdown_Arrow panels that contain an inner Button with the text.
    /// Searches through all child nodes including layouts (HorizontalLayout, RowLayout, etc.)
    /// </summary>
    /// <param name="panel">The panel to search within.</param>
    /// <returns>The first Button found, or null if none exists.</returns>
    private Button FindButtonInPanel(IUANode panel)
    {
        try
        {
            Log.Info("MenuSetup", $"    Searching for Button in: {panel.BrowseName} (has {panel.Children.Count()} children)");
            
            // First, check direct children for a Button
            foreach (var child in panel.Children)
            {
                Log.Info("MenuSetup", $"      Child: {child.BrowseName} Type: {child.GetType().Name}");
                
                if (child is Button btn)
                {
                    Log.Info("MenuSetup", $"    Found Button: {btn.BrowseName} in {panel.BrowseName}");
                    return btn;
                }
            }

            // If not found directly, search recursively in ALL child nodes
            // This handles layouts like HorizontalLayout1, RowLayout, ColumnLayout, etc.
            foreach (var child in panel.Children)
            {
                // Skip variables and other non-container nodes
                if (child.NodeClass == NodeClass.Object || child.NodeClass == NodeClass.ObjectType)
                {
                    var nestedButton = FindButtonInPanel(child);
                    if (nestedButton != null)
                        return nestedButton;
                }
            }

            Log.Info("MenuSetup", $"    No Button found in {panel.BrowseName}");
            return null;
        }
        catch (Exception ex)
        {
            Log.Warning("MenuSetup", $"    Error searching for button in {panel.BrowseName}: {ex.Message}");
            return null;
        }
    }

    /// <summary>
    /// Determines if a node is a folder (FolderType or has folder characteristics).
    /// </summary>
    /// <param name="node">The node to check.</param>
    /// <returns>True if the node is a folder, false otherwise.</returns>
    private bool IsFolder(IUANode node)
    {
        try
        {
            // Check if it's a Folder type
            if (node is FTOptix.Core.Folder)
            {
                Log.Info("MenuSetup", $"    [IsFolder] {node.BrowseName} IS FTOptix.Core.Folder");
                return true;
            }

            // Check the node class
            if (node.NodeClass == NodeClass.Object)
            {
                var objNode = node as UAManagedCore.UAObject;
                if (objNode != null)
                {
                    string typeName = objNode.ObjectType?.BrowseName ?? "";
                    Log.Info("MenuSetup", $"    [IsFolder] {node.BrowseName} ObjectType={typeName}");
                    if (typeName == "FolderType" || typeName.Contains("Folder"))
                        return true;
                }

                // Check if node has folder-like characteristics (contains other screens/folders)
                bool hasScreenOrFolder = node.Children.Any(c => IsScreen(c) || IsFolder(c));
                if (hasScreenOrFolder)
                {
                    Log.Info("MenuSetup", $"    [IsFolder] {node.BrowseName} has screen/folder children -> treating as folder");
                }
                return hasScreenOrFolder;
            }

            Log.Info("MenuSetup", $"    [IsFolder] {node.BrowseName} NodeClass={node.NodeClass} -> NOT folder");
            return false;
        }
        catch (Exception ex)
        {
            Log.Warning("MenuSetup", $"    [IsFolder] Error checking {node.BrowseName}: {ex.Message}");
            return false;
        }
    }

    /// <summary>
    /// Determines if a node should be treated as a menu item (screen/panel).
    /// 
    /// SIMPLIFIED LOGIC: If it's not a folder, assume it's a screen/menu item.
    /// This works because:
    /// - The _AutomaticMenuCreation_ folder only contains folders and screens
    /// - Screens may be ObjectType definitions that don't inherit from Screen base type
    /// - Any ObjectType or non-folder Object in this structure is a navigable screen
    /// </summary>
    /// <param name="node">The node to check.</param>
    /// <returns>True if the node should be treated as a menu item, false otherwise.</returns>
    private bool IsScreen(IUANode node)
    {
        try
        {
            // If it's a folder, it's not a screen
            if (IsFolder(node))
            {
                return false;
            }

            // ObjectType nodes (screen type definitions) - treat as screens
            if (node.NodeClass == NodeClass.ObjectType)
            {
                Log.Info("MenuSetup", $"    [IsScreen] {node.BrowseName} IS ObjectType -> treating as SCREEN");
                return true;
            }

            // Object nodes that are not folders - treat as screens
            if (node.NodeClass == NodeClass.Object)
            {
                Log.Info("MenuSetup", $"    [IsScreen] {node.BrowseName} IS Object (non-folder) -> treating as SCREEN");
                return true;
            }

            // Skip variables, methods, etc.
            Log.Info("MenuSetup", $"    [IsScreen] {node.BrowseName} NodeClass={node.NodeClass} -> NOT a screen");
            return false;
        }
        catch (Exception ex)
        {
            Log.Warning("MenuSetup", $"    [IsScreen] Error checking {node.BrowseName}: {ex.Message}");
            return false;
        }
    }

    /// <summary>
    /// Gets the full path to a node from the project root.
    /// </summary>
    /// <param name="node">The node to get the path for.</param>
    /// <returns>The full path string.</returns>
    private string GetNodePath(IUANode node)
    {
        try
        {
            // Build path by walking up the owner chain
            var pathParts = new List<string>();
            var current = node;

            while (current != null && current != Project.Current)
            {
                pathParts.Insert(0, current.BrowseName);
                current = current.Owner;
            }

            return string.Join("/", pathParts);
        }
        catch
        {
            return node.BrowseName;
        }
    }

    /// <summary>
    /// Formats a node name for display.
    /// - Removes any trailing "_L#" pattern (e.g., "_L1", "_L2", "_L3", etc.)
    /// - Replaces remaining underscores with spaces
    /// 
    /// Examples:
    ///   "Degumming_L2" -> "Degumming"
    ///   "CrudeHeatingCooling_L3" -> "Crude Heating Cooling"
    ///   "BleachFilter_A_L3" -> "Bleach Filter A"
    /// </summary>
    /// <param name="name">The raw node name.</param>
    /// <returns>Formatted display name.</returns>
    private string FormatDisplayName(string name)
    {
        if (string.IsNullOrEmpty(name))
            return name;

        // Remove trailing _L# pattern (where # is one or more digits)
        // Pattern: _L followed by digits at the end of the string
        string result = System.Text.RegularExpressions.Regex.Replace(name, @"_L\d+$", "");

        // Replace underscores with spaces for better readability
        result = result.Replace("_", " ");

        Log.Info("MenuSetup", $"    FormatDisplayName: '{name}' -> '{result}'");
        return result;
    }

    /// <summary>
    /// Sanitizes a name for use as a node BrowseName (removes special characters).
    /// </summary>
    /// <param name="name">The name to sanitize.</param>
    /// <returns>Sanitized name safe for use as BrowseName.</returns>
    private string SanitizeName(string name)
    {
        if (string.IsNullOrEmpty(name))
            return "Unknown";

        // Remove or replace characters that are not allowed in BrowseNames
        var sanitized = name
            .Replace(" ", "_")
            .Replace("-", "_")
            .Replace(".", "_")
            .Replace("/", "_")
            .Replace("\\", "_");

        // Ensure it starts with a letter
        if (char.IsDigit(sanitized[0]))
            sanitized = "_" + sanitized;

        return sanitized;
    }

    /// <summary>
    /// Cleans up previously generated menus from the output folder.
    /// Removes all menus that have the MENU_NAME_PREFIX.
    /// </summary>
    private void CleanupGeneratedMenus()
    {
        Log.Info("MenuSetup", "Cleaning up previously generated menus...");

        try
        {
            var menusToDelete = _outputFolder.Children
                .Where(c => c.BrowseName.StartsWith(MENU_NAME_PREFIX))
                .ToList();

            foreach (var menu in menusToDelete)
            {
                Log.Info("MenuSetup", $"Deleting menu: {menu.BrowseName}");
                menu.Delete();
            }

            Log.Info("MenuSetup", $"Cleaned up {menusToDelete.Count} menu(s)");
        }
        catch (Exception ex)
        {
            Log.Warning("MenuSetup", $"Error during cleanup: {ex.Message}");
        }
    }

    /// <summary>
    /// Links created menus to their trigger buttons in the UI.
    /// For each top-level folder in AutomaticMenuCreation, searches for a dropdown button
    /// named "Main_{FolderName}_Menu" anywhere in the UI folder and links it to the
    /// corresponding generated menu.
    /// </summary>
    /// <param name="sourceFolder">The source folder containing the menu structure.</param>
    private void LinkMenusToTriggerButtons(IUANode sourceFolder)
    {
        Log.Info("MenuSetup", "=== Linking menus to trigger buttons ===");

        try
        {
            // Get the UI folder to search within
            var uiFolder = Project.Current.Get("UI");
            if (uiFolder == null)
            {
                Log.Warning("MenuSetup", "UI folder not found, cannot link trigger buttons");
                return;
            }

            // Get all top-level folders from the source
            var topLevelFolders = sourceFolder.Children.Where(c => IsFolder(c)).ToList();

            foreach (var folder in topLevelFolders)
            {
                string folderName = folder.BrowseName;
                string triggerButtonName = $"Main_{folderName}_Menu";
                string menuName = $"{MENU_NAME_PREFIX}{folderName}";

                Log.Info("MenuSetup", $"Looking for trigger button: {triggerButtonName} for menu: {menuName}");

                // Find the created menu
                var createdMenu = _outputFolder.Get(menuName);
                if (createdMenu == null)
                {
                    Log.Warning("MenuSetup", $"  Menu '{menuName}' not found in output folder");
                    continue;
                }

                // Search for the trigger button anywhere in the UI folder
                var triggerButton = FindNodeByNameRecursive(uiFolder, triggerButtonName);
                if (triggerButton != null)
                {
                    // Link the menu to the trigger button's Panel property
                    string menuPath = GetNodePath(createdMenu);
                    ConfigurePanelProperty(triggerButton, menuPath);
                    Log.Info("MenuSetup", $"  SUCCESS: Linked {triggerButtonName} -> {menuName}");
                }
                else
                {
                    Log.Warning("MenuSetup", $"  Trigger button '{triggerButtonName}' not found in UI folder");
                }
            }

            Log.Info("MenuSetup", "=== Finished linking trigger buttons ===");
        }
        catch (Exception ex)
        {
            Log.Error("MenuSetup", $"Error linking trigger buttons: {ex.Message}");
        }
    }

    /// <summary>
    /// Recursively searches for a node with the specified name anywhere in the node tree.
    /// Searches through all children including nested objects, panels, layouts, etc.
    /// </summary>
    /// <param name="startNode">The node to start searching from.</param>
    /// <param name="targetName">The BrowseName of the node to find.</param>
    /// <returns>The found node, or null if not found.</returns>
    private IUANode FindNodeByNameRecursive(IUANode startNode, string targetName)
    {
        try
        {
            // Check if the current node matches
            if (startNode.BrowseName == targetName)
            {
                return startNode;
            }

            // Search through all children
            foreach (var child in startNode.Children)
            {
                // Skip variables - only search objects and types
                if (child.NodeClass == NodeClass.Variable)
                    continue;

                // Check direct match
                if (child.BrowseName == targetName)
                {
                    return child;
                }

                // Recursive search in child nodes (objects, object types, etc.)
                if (child.NodeClass == NodeClass.Object || child.NodeClass == NodeClass.ObjectType)
                {
                    var found = FindNodeByNameRecursive(child, targetName);
                    if (found != null)
                        return found;
                }
            }

            return null;
        }
        catch (Exception ex)
        {
            Log.Warning("MenuSetup", $"Error searching for node '{targetName}' in {startNode.BrowseName}: {ex.Message}");
            return null;
        }
    }

    #endregion

    #region Data Classes
    // ============================================================================
    // DATA CLASSES - Internal structures for organizing menu data
    // ============================================================================

    /// <summary>
    /// Represents information about a single menu item.
    /// Used internally to collect item data before creating buttons.
    /// </summary>
    private class MenuItemInfo
    {
        /// <summary>
        /// Display name shown on the button.
        /// </summary>
        public string Name { get; set; }

        /// <summary>
        /// Full path to the target (screen or submenu).
        /// </summary>
        public string NodePath { get; set; }

        /// <summary>
        /// True if this item opens a submenu, false if it navigates directly.
        /// </summary>
        public bool IsSubmenu { get; set; }

        /// <summary>
        /// Reference to the source node (screen or folder).
        /// </summary>
        public IUANode SourceNode { get; set; }

        /// <summary>
        /// Reference to the created submenu panel (if IsSubmenu is true).
        /// </summary>
        public IUANode SubmenuPanel { get; set; }
    }

    #endregion
}
